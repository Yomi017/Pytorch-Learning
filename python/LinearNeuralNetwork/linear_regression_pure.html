<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çº¿æ€§å›å½’è®­ç»ƒè¿‡ç¨‹åŠ¨ç”»</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
        }
        .controls button:hover {
            background-color: #45a049;
        }
        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .info-box {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        .parameters {
            background-color: #e3f2fd;
            border-color: #2196F3;
        }
        .loss-info {
            background-color: #fff3e0;
            border-color: #ff9800;
        }
        .epoch-info {
            background-color: #f3e5f5;
            border-color: #9c27b0;
        }
        .gradient-info {
            background-color: #e8f5e8;
            border-color: #4caf50;
        }
        .chart-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .chart-wrapper {
            position: relative;
            border: 2px solid #333;
            border-radius: 8px;
            background-color: white;
        }
        canvas {
            border-radius: 6px;
        }
        .step-indicator {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f0f0;
            border-radius: 8px;
            border-left: 5px solid #4CAF50;
        }
        .highlight {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { background-color: inherit; }
            50% { background-color: #ffeb3b; }
            100% { background-color: inherit; }
        }
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; color: #333;">çº¿æ€§å›å½’è®­ç»ƒè¿‡ç¨‹åŠ¨ç”»æ¼”ç¤º</h1>
        
        <div class="controls">
            <button onclick="startAnimation()">å¼€å§‹è®­ç»ƒ</button>
            <button onclick="resetAnimation()">é‡ç½®</button>
            <button onclick="pauseAnimation()" id="pauseBtn">æš‚åœ</button>
        </div>

        <div class="step-indicator" id="stepIndicator">
            ç‚¹å‡»"å¼€å§‹è®­ç»ƒ"æŸ¥çœ‹è®­ç»ƒè¿‡ç¨‹
        </div>

        <div class="info-panel">
            <div class="info-box parameters" id="paramBox">
                <h3>ğŸ“Š å½“å‰å‚æ•°</h3>
                <p><strong>w (æƒé‡):</strong> <span id="currentW">éšæœºåˆå§‹åŒ–</span></p>
                <p><strong>b (åç½®):</strong> <span id="currentB">éšæœºåˆå§‹åŒ–</span></p>
                <p><strong>çœŸå®å‚æ•°:</strong> w=2.0, b=1.0</p>
            </div>
            
            <div class="info-box loss-info" id="lossBox">
                <h3>ğŸ“ˆ æŸå¤±ä¿¡æ¯</h3>
                <p><strong>å½“å‰æŸå¤±:</strong> <span id="currentLoss">--</span></p>
                <p><strong>å­¦ä¹ ç‡:</strong> <span id="learningRate">0.1</span></p>
                <p><strong>æ ·æœ¬æ•°é‡:</strong> <span id="sampleCount">50</span></p>
            </div>
            
            <div class="info-box epoch-info" id="epochBox">
                <h3>ğŸ”„ è®­ç»ƒä¿¡æ¯</h3>
                <p><strong>å½“å‰è½®æ¬¡:</strong> <span id="currentEpoch">0</span></p>
                <p><strong>æ€»è½®æ¬¡:</strong> <span id="totalEpochs">50</span></p>
                <p><strong>è®­ç»ƒçŠ¶æ€:</strong> <span id="trainingStatus">æœªå¼€å§‹</span></p>
            </div>
            
            <div class="info-box gradient-info" id="gradBox">
                <h3>ğŸ“‰ æ¢¯åº¦ä¿¡æ¯</h3>
                <p><strong>wçš„æ¢¯åº¦:</strong> <span id="gradW">--</span></p>
                <p><strong>bçš„æ¢¯åº¦:</strong> <span id="gradB">--</span></p>
                <p><strong>æ›´æ–°æ–¹å‘:</strong> <span id="updateDirection">--</span></p>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-wrapper">
                <div class="chart-title">æ•°æ®ç‚¹ä¸æ‹Ÿåˆç›´çº¿</div>
                <canvas id="dataChart" width="600" height="400"></canvas>
            </div>
            <div class="chart-wrapper">
                <div class="chart-title">æŸå¤±å‡½æ•°å˜åŒ–</div>
                <canvas id="lossChart" width="400" height="400"></canvas>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let isAnimating = false;
        let isPaused = false;
        
        // è®­ç»ƒå‚æ•°
        let w = Math.random() * 2 - 1; // éšæœºåˆå§‹åŒ– [-1, 1]
        let b = Math.random() * 2 - 1; // éšæœºåˆå§‹åŒ– [-1, 1]
        const trueW = 2.0;
        const trueB = 1.0;
        const learningRate = 0.1;
        const numSamples = 50;
        const maxEpochs = 50;
        let currentEpoch = 0;
        
        // æ•°æ®
        let xData = [];
        let yTrue = [];
        let yPred = [];
        let lossHistory = [];
        
        // Canvas ä¸Šä¸‹æ–‡
        let dataCtx, lossCtx;
        
        // åˆå§‹åŒ–
        function init() {
            generateData();
            initCanvas();
            updateDisplay();
            drawCharts();
        }
        
        // ç”Ÿæˆè®­ç»ƒæ•°æ®
        function generateData() {
            xData = [];
            yTrue = [];
            for (let i = 0; i < numSamples; i++) {
                const x = (i / numSamples) * 10 - 5; // xèŒƒå›´: -5 to 5
                const noise = (Math.random() - 0.5) * 0.5; // æ·»åŠ å™ªå£°
                xData.push(x);
                yTrue.push(trueW * x + trueB + noise);
            }
        }
        
        // åˆå§‹åŒ–Canvas
        function initCanvas() {
            const dataCanvas = document.getElementById('dataChart');
            const lossCanvas = document.getElementById('lossChart');
            dataCtx = dataCanvas.getContext('2d');
            lossCtx = lossCanvas.getContext('2d');
        }
        
        // ç»˜åˆ¶æ•°æ®å›¾è¡¨
        function drawDataChart() {
            const canvas = document.getElementById('dataChart');
            const ctx = dataCtx;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // è®¾ç½®åæ ‡ç³»
            const padding = 50;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;
            
            // è®¡ç®—æ•°æ®èŒƒå›´
            const xMin = Math.min(...xData);
            const xMax = Math.max(...xData);
            const yMin = Math.min(...yTrue) - 2;
            const yMax = Math.max(...yTrue) + 2;
            
            // åæ ‡è½¬æ¢å‡½æ•°
            function toCanvasX(x) {
                return padding + ((x - xMin) / (xMax - xMin)) * chartWidth;
            }
            
            function toCanvasY(y) {
                return padding + ((yMax - y) / (yMax - yMin)) * chartHeight;
            }
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Xè½´
            ctx.moveTo(padding, toCanvasY(0));
            ctx.lineTo(padding + chartWidth, toCanvasY(0));
            // Yè½´
            ctx.moveTo(toCanvasX(0), padding);
            ctx.lineTo(toCanvasX(0), padding + chartHeight);
            ctx.stroke();
            
            // ç»˜åˆ¶çœŸå®æ•°æ®ç‚¹
            ctx.fillStyle = 'rgba(54, 162, 235, 0.8)';
            for (let i = 0; i < numSamples; i++) {
                ctx.beginPath();
                ctx.arc(toCanvasX(xData[i]), toCanvasY(yTrue[i]), 4, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // ç»˜åˆ¶çœŸå®ç›´çº¿ï¼ˆè™šçº¿ï¼‰
            ctx.strokeStyle = 'rgba(75, 192, 192, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xMin), toCanvasY(trueW * xMin + trueB));
            ctx.lineTo(toCanvasX(xMax), toCanvasY(trueW * xMax + trueB));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç»˜åˆ¶é¢„æµ‹ç›´çº¿
            ctx.strokeStyle = 'rgba(255, 99, 132, 1)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xMin), toCanvasY(w * xMin + b));
            ctx.lineTo(toCanvasX(xMax), toCanvasY(w * xMax + b));
            ctx.stroke();
            
            // æ·»åŠ å›¾ä¾‹
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333';
            ctx.fillText('ğŸ”µ çœŸå®æ•°æ®ç‚¹', padding, 20);
            ctx.fillText('ğŸ”´ é¢„æµ‹ç›´çº¿', padding + 120, 20);
            ctx.fillText('ğŸŸ¢ çœŸå®ç›´çº¿', padding + 220, 20);
        }
        
        // ç»˜åˆ¶æŸå¤±å›¾è¡¨
        function drawLossChart() {
            const canvas = document.getElementById('lossChart');
            const ctx = lossCtx;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (lossHistory.length === 0) return;
            
            const padding = 50;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;
            
            // è®¡ç®—æŸå¤±èŒƒå›´
            const maxLoss = Math.max(...lossHistory);
            const minLoss = Math.min(...lossHistory);
            const lossRange = maxLoss - minLoss;
            
            // åæ ‡è½¬æ¢å‡½æ•°
            function toCanvasX(epoch) {
                return padding + (epoch / Math.max(lossHistory.length - 1, 1)) * chartWidth;
            }
            
            function toCanvasY(loss) {
                if (lossRange === 0) return padding + chartHeight / 2;
                return padding + ((maxLoss - loss) / lossRange) * chartHeight;
            }
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Xè½´
            ctx.moveTo(padding, padding + chartHeight);
            ctx.lineTo(padding + chartWidth, padding + chartHeight);
            // Yè½´
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, padding + chartHeight);
            ctx.stroke();
            
            // ç»˜åˆ¶æŸå¤±æ›²çº¿
            if (lossHistory.length > 1) {
                ctx.strokeStyle = 'rgba(255, 159, 64, 1)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(toCanvasX(0), toCanvasY(lossHistory[0]));
                for (let i = 1; i < lossHistory.length; i++) {
                    ctx.lineTo(toCanvasX(i), toCanvasY(lossHistory[i]));
                }
                ctx.stroke();
                
                // å¡«å……åŒºåŸŸ
                ctx.fillStyle = 'rgba(255, 159, 64, 0.2)';
                ctx.beginPath();
                ctx.moveTo(toCanvasX(0), padding + chartHeight);
                ctx.lineTo(toCanvasX(0), toCanvasY(lossHistory[0]));
                for (let i = 1; i < lossHistory.length; i++) {
                    ctx.lineTo(toCanvasX(i), toCanvasY(lossHistory[i]));
                }
                ctx.lineTo(toCanvasX(lossHistory.length - 1), padding + chartHeight);
                ctx.closePath();
                ctx.fill();
            }
            
            // ç»˜åˆ¶å½“å‰ç‚¹
            if (lossHistory.length > 0) {
                ctx.fillStyle = 'rgba(255, 99, 132, 1)';
                ctx.beginPath();
                ctx.arc(toCanvasX(lossHistory.length - 1), toCanvasY(lossHistory[lossHistory.length - 1]), 4, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // æ·»åŠ æ ‡ç­¾
            ctx.font = '12px Arial';
            ctx.fillStyle = '#333';
            ctx.fillText('è½®æ¬¡', padding + chartWidth / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(15, padding + chartHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('æŸå¤±å€¼', 0, 0);
            ctx.restore();
        }
        
        // ç»˜åˆ¶æ‰€æœ‰å›¾è¡¨
        function drawCharts() {
            drawDataChart();
            drawLossChart();
        }
        
        // å‰å‘ä¼ æ’­
        function forwardPass() {
            yPred = xData.map(x => w * x + b);
            return yPred;
        }
        
        // è®¡ç®—æŸå¤±
        function calculateLoss() {
            const predictions = forwardPass();
            let totalLoss = 0;
            for (let i = 0; i < numSamples; i++) {
                const diff = predictions[i] - yTrue[i];
                totalLoss += diff * diff;
            }
            return totalLoss / numSamples; // å‡æ–¹è¯¯å·®
        }
        
        // è®¡ç®—æ¢¯åº¦
        function calculateGradients() {
            const predictions = forwardPass();
            let gradW = 0;
            let gradB = 0;
            
            for (let i = 0; i < numSamples; i++) {
                const diff = predictions[i] - yTrue[i];
                gradW += 2 * diff * xData[i];
                gradB += 2 * diff;
            }
            
            gradW /= numSamples;
            gradB /= numSamples;
            
            return { gradW, gradB };
        }
        
        // åå‘ä¼ æ’­æ›´æ–°å‚æ•°
        function backwardPass() {
            const { gradW, gradB } = calculateGradients();
            
            // æ›´æ–°å‚æ•°
            w = w - learningRate * gradW;
            b = b - learningRate * gradB;
            
            return { gradW, gradB };
        }
        
        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            document.getElementById('currentW').textContent = w.toFixed(4);
            document.getElementById('currentB').textContent = b.toFixed(4);
            document.getElementById('currentEpoch').textContent = currentEpoch;
            document.getElementById('learningRate').textContent = learningRate;
            document.getElementById('sampleCount').textContent = numSamples;
            document.getElementById('totalEpochs').textContent = maxEpochs;
            
            const loss = calculateLoss();
            document.getElementById('currentLoss').textContent = loss.toFixed(6);
            
            // æ›´æ–°æŸå¤±å†å²
            if (currentEpoch > 0) {
                lossHistory[currentEpoch - 1] = loss;
            } else {
                lossHistory.push(loss);
            }
            
            // é‡ç»˜å›¾è¡¨
            drawCharts();
        }
        
        // è®­ç»ƒä¸€æ­¥
        async function trainStep() {
            return new Promise(resolve => {
                // é«˜äº®å½“å‰æ­¥éª¤
                highlightStep('forward');
                document.getElementById('stepIndicator').textContent = 
                    `ç¬¬ ${currentEpoch + 1} è½® - å‰å‘ä¼ æ’­: è®¡ç®—é¢„æµ‹å€¼ Å· = wx + b`;
                
                setTimeout(() => {
                    // å‰å‘ä¼ æ’­
                    forwardPass();
                    
                    // é«˜äº®æŸå¤±è®¡ç®—
                    highlightStep('loss');
                    document.getElementById('stepIndicator').textContent = 
                        `ç¬¬ ${currentEpoch + 1} è½® - è®¡ç®—æŸå¤±: MSE = (1/n)Î£(Å· - y)Â²`;
                    
                    setTimeout(() => {
                        // è®¡ç®—æŸå¤±å’Œæ¢¯åº¦
                        const loss = calculateLoss();
                        const { gradW, gradB } = calculateGradients();
                        
                        // æ›´æ–°æ¢¯åº¦æ˜¾ç¤º
                        document.getElementById('gradW').textContent = gradW.toFixed(6);
                        document.getElementById('gradB').textContent = gradB.toFixed(6);
                        
                        const direction = gradW > 0 ? 'wå‡å°' : 'wå¢å¤§';
                        document.getElementById('updateDirection').textContent = direction;
                        
                        // é«˜äº®åå‘ä¼ æ’­
                        highlightStep('backward');
                        document.getElementById('stepIndicator').textContent = 
                            `ç¬¬ ${currentEpoch + 1} è½® - åå‘ä¼ æ’­: æ›´æ–°å‚æ•° w = w - Î±âˆ‡w, b = b - Î±âˆ‡b`;
                        
                        setTimeout(() => {
                            // åå‘ä¼ æ’­
                            backwardPass();
                            currentEpoch++;
                            
                            // æ›´æ–°æ˜¾ç¤º
                            updateDisplay();
                            
                            // æ£€æŸ¥æ”¶æ•›æˆ–å®Œæˆ
                            if (loss < 0.01) {
                                document.getElementById('stepIndicator').textContent = 
                                    `ğŸ‰ è®­ç»ƒå®Œæˆï¼æŸå¤±å·²æ”¶æ•›åˆ° ${loss.toFixed(6)}`;
                                document.getElementById('trainingStatus').textContent = 'å·²æ”¶æ•›';
                                isAnimating = false;
                            } else if (currentEpoch >= maxEpochs) {
                                document.getElementById('stepIndicator').textContent = 
                                    `â¹ï¸ è¾¾åˆ°æœ€å¤§è½®æ¬¡ï¼æœ€ç»ˆæŸå¤±: ${loss.toFixed(6)}`;
                                document.getElementById('trainingStatus').textContent = 'è®­ç»ƒå®Œæˆ';
                                isAnimating = false;
                            } else {
                                document.getElementById('trainingStatus').textContent = 'è®­ç»ƒä¸­...';
                            }
                            
                            clearHighlight();
                            resolve();
                        }, 800);
                    }, 800);
                }, 800);
            });
        }
        
        // é«˜äº®æ­¥éª¤
        function highlightStep(step) {
            clearHighlight();
            if (step === 'forward') {
                document.getElementById('paramBox').classList.add('highlight');
            } else if (step === 'loss') {
                document.getElementById('lossBox').classList.add('highlight');
            } else if (step === 'backward') {
                document.getElementById('gradBox').classList.add('highlight');
            }
        }
        
        // æ¸…é™¤é«˜äº®
        function clearHighlight() {
            document.querySelectorAll('.info-box').forEach(box => {
                box.classList.remove('highlight');
            });
        }
        
        // å¼€å§‹åŠ¨ç”»
        async function startAnimation() {
            if (isAnimating) return;
            
            isAnimating = true;
            isPaused = false;
            document.getElementById('pauseBtn').textContent = 'æš‚åœ';
            document.getElementById('trainingStatus').textContent = 'è®­ç»ƒä¸­...';
            
            while (isAnimating && currentEpoch < maxEpochs) {
                if (!isPaused) {
                    await trainStep();
                    await new Promise(resolve => setTimeout(resolve, 500)); // æ§åˆ¶åŠ¨ç”»é€Ÿåº¦
                } else {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }
        
        // æš‚åœ/ç»§ç»­åŠ¨ç”»
        function pauseAnimation() {
            if (!isAnimating) return;
            
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'ç»§ç»­' : 'æš‚åœ';
            document.getElementById('trainingStatus').textContent = isPaused ? 'å·²æš‚åœ' : 'è®­ç»ƒä¸­...';
        }
        
        // é‡ç½®åŠ¨ç”»
        function resetAnimation() {
            isAnimating = false;
            isPaused = false;
            currentEpoch = 0;
            
            // é‡æ–°éšæœºåˆå§‹åŒ–å‚æ•°
            w = Math.random() * 2 - 1;
            b = Math.random() * 2 - 1;
            
            // æ¸…ç©ºæŸå¤±å†å²
            lossHistory = [];
            
            // é‡ç½®æ˜¾ç¤º
            document.getElementById('trainingStatus').textContent = 'æœªå¼€å§‹';
            document.getElementById('stepIndicator').textContent = 'ç‚¹å‡»"å¼€å§‹è®­ç»ƒ"æŸ¥çœ‹è®­ç»ƒè¿‡ç¨‹';
            document.getElementById('pauseBtn').textContent = 'æš‚åœ';
            document.getElementById('gradW').textContent = '--';
            document.getElementById('gradB').textContent = '--';
            document.getElementById('updateDirection').textContent = '--';
            
            clearHighlight();
            updateDisplay();
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = function() {
            init();
        };
    </script>
</body>
</html>